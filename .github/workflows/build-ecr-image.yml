name: Deploy Notifications Platform

# Trigger on branch pushes (non-prod) and version tags (prod only)
on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
        - dev
        - staging
        - prod
  push:
    branches: [staging, dev]
    paths: 
      - 'admin/**'
      - 'requestor/**'
      - 'worker/**'
      - '**/Dockerfile'
      - '**/requirements.txt'
      - '**/docker-compose.yml'
      - '.github/workflows/**'
    tags: ['v*.*.*']

permissions:
  id-token: write    # Required for OIDC authentication
  contents: write    # Required for creating GitHub releases 
  actions: read      # Required for workflow access
  security-events: write  # Required for uploading SARIF results

env:
  AWS_REGION: us-east-1  # AWS region for ECR and ECS
  SERVICES: 'admin requestor worker'  # Microservices to deploy

jobs:
  deploy:
    runs-on: ubuntu-latest
    # environment: ${{ github.ref_type == 'tag' && 'production' || (github.ref_name == 'staging' && 'staging' || 'dev') }}  
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch full history for proper tagging
    
    # Determine deployment context (branch vs tag)
    - name: Set deployment context
      id: context
      run: |
        if [[ "${{ github.ref_type }}" == "tag" ]]; then
          # Tagged release - extract version and set prod environment
          VERSION=${GITHUB_REF#refs/tags/}
          echo "ENVIRONMENT=prod" >> $GITHUB_ENV
          echo "VERSION_TAG=$VERSION" >> $GITHUB_ENV
          echo "IS_RELEASE=true" >> $GITHUB_ENV
          echo "IMAGE_TAG=$VERSION" >> $GITHUB_ENV
          echo "Deploying release $VERSION to production"
        else
          # Branch deployment - use commit SHA, environment, and timestamp
          SHORT_SHA=${GITHUB_SHA:0:7}
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          echo "IS_RELEASE=false" >> $GITHUB_ENV
          
          case "${{ github.ref_name }}" in
            "staging")
              echo "ENVIRONMENT=staging" >> $GITHUB_ENV
              echo "IMAGE_TAG=$SHORT_SHA-staging-$TIMESTAMP" >> $GITHUB_ENV
              ;;
            "dev")
              echo "ENVIRONMENT=dev" >> $GITHUB_ENV
              echo "IMAGE_TAG=$SHORT_SHA-dev-$TIMESTAMP" >> $GITHUB_ENV
              ;;
            *)
              echo "ENVIRONMENT=dev" >> $GITHUB_ENV
              echo "IMAGE_TAG=$SHORT_SHA-dev-$TIMESTAMP" >> $GITHUB_ENV
              ;;
          esac
          echo "Deploying branch ${{ github.ref_name }} to $ENVIRONMENT with tag $IMAGE_TAG"
        fi
    
    # Add this step before "Configure AWS credentials"
    - name: Debug Deployment Context
      run: |
        echo "ðŸ” Deployment Trigger Information:"
        echo "Repository: ${{ github.repository }}"
        echo "Ref: ${{ github.ref }}"
        echo "Ref Name: ${{ github.ref_name }}"
        echo "Ref Type: ${{ github.ref_type }}"
        echo "Actor: ${{ github.actor }}"
        echo "Event Name: ${{ github.event_name }}"
        echo "Commit SHA: ${{ github.sha }}"
        echo "Workflow: ${{ github.workflow }}"
        echo "AWS Role ARN: ${{ secrets.AWS_ROLE_ARN }}"
        echo "Expected sub: repo:${{ github.repository }}:ref:${{ github.ref }}"
        echo "ðŸ“ Changed Files:"
        git diff --name-only HEAD~1 HEAD || echo "No previous commit to compare"


    # Configure AWS credentials using OIDC
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: ${{ env.AWS_REGION }}
        role-session-name: GitHubActions-${{ env.ENVIRONMENT }}-Deploy
    
    # Login to Amazon ECR
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
    
    # Build Docker images with proper tagging
    - name: Build Docker images
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
      run: |
        echo "Building images for environment: $ENVIRONMENT"
        echo "Image tag: $IMAGE_TAG"
        
        for SERVICE in $SERVICES; do
          echo "Building $SERVICE..."
          
          if [[ "$IS_RELEASE" == "true" ]]; then
            # Production release: tag with version only (semantic versioning)
            docker build -t $ECR_REGISTRY/$SERVICE-prod:$VERSION_TAG \
                        ./$SERVICE
            echo "âœ… Built $SERVICE-prod:$VERSION_TAG"
          else
            # Branch deployment: tag with commit-sha-environment-timestamp
            docker build -t $ECR_REGISTRY/$SERVICE-$ENVIRONMENT:$IMAGE_TAG \
                        ./$SERVICE
            echo "âœ… Built $SERVICE-$ENVIRONMENT:$IMAGE_TAG"
          fi
        done
    
    # Scan Docker images for vulnerabilities with Trivy
    - name: Run Trivy vulnerability scanner
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
      run: |
        # Install Trivy
        sudo apt-get update
        sudo apt-get install wget apt-transport-https gnupg lsb-release
        wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
        echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
        sudo apt-get update
        sudo apt-get install trivy
        
        # Create reports directory
        mkdir -p trivy-reports
        
        echo "ðŸ” Scanning Docker images for vulnerabilities..."
        
        for SERVICE in $SERVICES; do
          if [[ "$IS_RELEASE" == "true" ]]; then
            IMAGE_NAME="$ECR_REGISTRY/$SERVICE-prod:$VERSION_TAG"
          else
            IMAGE_NAME="$ECR_REGISTRY/$SERVICE-$ENVIRONMENT:$IMAGE_TAG"
          fi
          
          echo "Scanning $IMAGE_NAME..."
          
          # Run Trivy scan with multiple output formats
          trivy image \
            --format table \
            --severity HIGH,CRITICAL \
            --no-progress \
            $IMAGE_NAME
          
          # Generate JSON report for artifacts
          trivy image \
            --format json \
            --output trivy-reports/$SERVICE-scan.json \
            --severity HIGH,CRITICAL \
            --no-progress \
            $IMAGE_NAME
          
          # Generate SARIF report for GitHub Security tab
          trivy image \
            --format sarif \
            --output trivy-reports/$SERVICE-scan.sarif \
            --severity HIGH,CRITICAL \
            --no-progress \
            $IMAGE_NAME
          
          echo "âœ… Scan completed for $SERVICE"
        done
    
    # Upload Trivy scan results
    - name: Upload Trivy scan results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: trivy-vulnerability-reports
        path: trivy-reports/
        retention-days: 30
    
    # Upload SARIF results to GitHub Security tab
    - name: Upload Trivy SARIF results
      if: always()
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: trivy-reports/
    
    # Check for critical vulnerabilities and fail if found
    - name: Check vulnerability scan results
      run: |
        echo "ðŸ” Checking for critical vulnerabilities..."
        
        CRITICAL_FOUND=false
        
        for SERVICE in $SERVICES; do
          if [ -f "trivy-reports/$SERVICE-scan.json" ]; then
            CRITICAL_COUNT=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "CRITICAL")] | length' trivy-reports/$SERVICE-scan.json 2>/dev/null || echo "0")
            HIGH_COUNT=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "HIGH")] | length' trivy-reports/$SERVICE-scan.json 2>/dev/null || echo "0")
            
            echo "$SERVICE: $CRITICAL_COUNT critical, $HIGH_COUNT high severity vulnerabilities"
            
            if [ "$CRITICAL_COUNT" -gt 0 ]; then
              CRITICAL_FOUND=true
              echo "âŒ Critical vulnerabilities found in $SERVICE"
            fi
          fi
        done
        
        if [ "$CRITICAL_FOUND" = true ]; then
          echo "ðŸš¨ Deployment blocked due to critical vulnerabilities"
          echo "Review the Trivy reports and fix critical issues before deployment"
          exit 1
        else
          echo "âœ… No critical vulnerabilities found, proceeding with deployment"
        fi
    
    # Push Docker images to ECR (only after successful vulnerability scan)
    - name: Push Docker images to ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
      run: |
        echo "Pushing images to ECR after successful vulnerability scan..."
        
        for SERVICE in $SERVICES; do
          if [[ "$IS_RELEASE" == "true" ]]; then
            docker push $ECR_REGISTRY/$SERVICE-prod:$VERSION_TAG
            echo "âœ… Pushed $SERVICE-prod:$VERSION_TAG"
          else
            docker push $ECR_REGISTRY/$SERVICE-$ENVIRONMENT:$IMAGE_TAG
            echo "âœ… Pushed $SERVICE-$ENVIRONMENT:$IMAGE_TAG"
          fi
        done
    
    # Human approval checkpoint for production
    - name: Production deployment approval
      if: env.IS_RELEASE == 'true'
      run: |
        echo "ðŸ”’ Production deployment requires manual approval"
        echo "Deploying $VERSION_TAG to production ECS cluster"
    
    # Update task definitions with new images
    - name: Update ECS Task Definitions
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
      run: |
        CLUSTER_NAME="YANTECH-cluster-$ENVIRONMENT"
        echo "Updating task definitions with new images..."
        
        for SERVICE in $SERVICES; do
          TASK_FAMILY="YANTECH-${SERVICE}-$ENVIRONMENT"
          
          if [[ "$IS_RELEASE" == "true" ]]; then
            NEW_IMAGE="$ECR_REGISTRY/$SERVICE-prod:$VERSION_TAG"
          else
            NEW_IMAGE="$ECR_REGISTRY/$SERVICE-$ENVIRONMENT:$IMAGE_TAG"
          fi
          
          echo "ðŸ“ Updating $TASK_FAMILY with image: $NEW_IMAGE"
          
          # Get current task definition
          TASK_DEF=$(aws ecs describe-task-definition --task-definition $TASK_FAMILY --query 'taskDefinition')
          
          # Update image in task definition
          NEW_TASK_DEF=$(echo $TASK_DEF | jq --arg IMAGE "$NEW_IMAGE" '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy)')
          
          # Register new task definition
          aws ecs register-task-definition --cli-input-json "$NEW_TASK_DEF" --no-cli-pager
          
          echo "âœ… Updated task definition: $TASK_FAMILY"
        done
    
    # Deploy to ECS with service updates (EC2 launch type)
    - name: Deploy to ECS
      run: |
        CLUSTER_NAME="YANTECH-cluster-$ENVIRONMENT"
        echo "Deploying to ECS cluster: $CLUSTER_NAME"
        
        # Check cluster status first
        CLUSTER_STATUS=$(aws ecs describe-clusters --clusters $CLUSTER_NAME --query 'clusters[0].status' --output text)
        ACTIVE_INSTANCES=$(aws ecs describe-clusters --clusters $CLUSTER_NAME --query 'clusters[0].registeredContainerInstancesCount' --output text)
        
        echo "Cluster Status: $CLUSTER_STATUS"
        echo "Active EC2 Instances: $ACTIVE_INSTANCES"
        
        if [ "$CLUSTER_STATUS" != "ACTIVE" ]; then
          echo "âŒ ECS Cluster is not active: $CLUSTER_STATUS"
          exit 1
        fi
        
        if [ "$ACTIVE_INSTANCES" = "0" ]; then
          echo "âŒ No EC2 instances registered in cluster. Check Auto Scaling Group and ECS agent."
          exit 1
        fi
        
        # Update each microservice with new task definition
        for SERVICE in $SERVICES; do
          SERVICE_NAME="YANTECH-${SERVICE}-service-$ENVIRONMENT"
          TASK_FAMILY="YANTECH-${SERVICE}-$ENVIRONMENT"
          
          echo "ðŸš€ Updating ECS service: $SERVICE_NAME"
          
          # Check if service exists
          SERVICE_EXISTS=$(aws ecs describe-services --cluster $CLUSTER_NAME --services $SERVICE_NAME --query 'services[0].serviceName' --output text 2>/dev/null)
          
          if [ "$SERVICE_EXISTS" = "None" ] || [ -z "$SERVICE_EXISTS" ]; then
            echo "âŒ Service $SERVICE_NAME not found in cluster $CLUSTER_NAME"
            echo "Available services:"
            aws ecs list-services --cluster $CLUSTER_NAME --query 'serviceArns' --output table
            continue
          fi
          
          # Update service with new task definition
          aws ecs update-service \
            --cluster $CLUSTER_NAME \
            --service $SERVICE_NAME \
            --task-definition $TASK_FAMILY \
            --force-new-deployment \
            --no-cli-pager && echo "âœ… Service $SERVICE_NAME update initiated" || echo "âŒ Failed to update $SERVICE_NAME"
          
          # Verify the service update was accepted
          sleep 5
          CURRENT_TASK_DEF=$(aws ecs describe-services --cluster $CLUSTER_NAME --services $SERVICE_NAME --query 'services[0].taskDefinition' --output text)
          echo "ðŸ” Service $SERVICE_NAME now using: $CURRENT_TASK_DEF"
        done
    
    # Wait for ECS services to deploy (EC2 launch type) - FAST VERSION
    - name: Wait for ECS deployment completion
      run: |
        echo "Waiting for ECS services to deploy (EC2 launch type)..."
        
        CLUSTER_NAME="YANTECH-cluster-$ENVIRONMENT"
        ACTIVE_INSTANCES=$(aws ecs describe-clusters --clusters $CLUSTER_NAME --query 'clusters[0].registeredContainerInstancesCount' --output text)
        echo "Active EC2 instances in cluster: $ACTIVE_INSTANCES"
        
        if [ "$ACTIVE_INSTANCES" = "0" ]; then
          echo "âŒ No EC2 instances registered in ECS cluster."
          exit 1
        fi
        
        # Wait for each service with simple running count check (faster)
        for SERVICE in $SERVICES; do
          SERVICE_NAME="YANTECH-${SERVICE}-service-$ENVIRONMENT"
          echo "â³ Checking service: $SERVICE_NAME"
          
          # Simple check: wait for running count = desired count (max 3 minutes)
          for i in {1..18}; do
            RUNNING=$(aws ecs describe-services --cluster $CLUSTER_NAME --services $SERVICE_NAME --query 'services[0].runningCount' --output text 2>/dev/null || echo "0")
            DESIRED=$(aws ecs describe-services --cluster $CLUSTER_NAME --services $SERVICE_NAME --query 'services[0].desiredCount' --output text 2>/dev/null || echo "1")
            
            echo "  Attempt $i: $SERVICE_NAME running $RUNNING/$DESIRED tasks"
            
            if [ "$RUNNING" = "$DESIRED" ] && [ "$RUNNING" != "0" ]; then
              echo "âœ… Service $SERVICE_NAME is running ($RUNNING/$DESIRED)"
              break
            fi
            
            if [ $i -eq 18 ]; then
              echo "âš ï¸ Service $SERVICE_NAME did not reach desired state in 3 minutes"
              # Show status but don't fail
              aws ecs describe-services --cluster $CLUSTER_NAME --services $SERVICE_NAME \
                --query 'services[0].{Status:status,Running:runningCount,Desired:desiredCount,Events:events[0].message}' --output table
            fi
            
            sleep 10
          done
        done
        
        echo "âœ… All services deployment check completed for $ENVIRONMENT"
    
    # Create GitHub Release for tagged versions
    - name: Create GitHub Release
      if: env.IS_RELEASE == 'true'
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ env.VERSION_TAG }}
        name: Release ${{ env.VERSION_TAG }}
        body: |
          ## ðŸš€ Production Deployment ${{ env.VERSION_TAG }}
          
          **Deployed Services:**
          - Admin Service: `admin-prod:${{ env.VERSION_TAG }}`
          - Requestor Service: `requestor-prod:${{ env.VERSION_TAG }}`
          - Worker Service: `worker-prod:${{ env.VERSION_TAG }}`
          
          **ECS Cluster:** `YANTECH-cluster-prod`
          
          **Deployment Details:**
          - Commit: ${{ github.sha }}
          - Deployed at: ${{ github.event.head_commit.timestamp }}
          - Triggered by: @${{ github.actor }}
          
          **Docker Images:**
          ```
          ${{ steps.login-ecr.outputs.registry }}/admin-prod:${{ env.VERSION_TAG }}
          ${{ steps.login-ecr.outputs.registry }}/requestor-prod:${{ env.VERSION_TAG }}
          ${{ steps.login-ecr.outputs.registry }}/worker-prod:${{ env.VERSION_TAG }}
          ```
          
          **Tagging Strategy:**
          - Production releases use semantic versioning (e.g., v1.2.3)
          - Branch deployments use commit-sha-environment-timestamp format
        draft: false
        prerelease: false
        generate_release_notes: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    # Deployment summary with health checks and security scan results
    - name: Deployment Summary
      run: |
        CLUSTER_NAME="YANTECH-cluster-$ENVIRONMENT"
        
        echo "## ðŸ“‹ Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Environment:** $ENVIRONMENT" >> $GITHUB_STEP_SUMMARY
        echo "**Image Tag:** $IMAGE_TAG" >> $GITHUB_STEP_SUMMARY
        echo "**Services Deployed:** $SERVICES" >> $GITHUB_STEP_SUMMARY
        echo "**ECS Cluster:** $CLUSTER_NAME" >> $GITHUB_STEP_SUMMARY
        echo "**Launch Type:** EC2" >> $GITHUB_STEP_SUMMARY
        
        # Add vulnerability scan results
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ”’ Security Scan Results" >> $GITHUB_STEP_SUMMARY
        for SERVICE in $SERVICES; do
          if [ -f "trivy-reports/$SERVICE-scan.json" ]; then
            CRITICAL_COUNT=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "CRITICAL")] | length' trivy-reports/$SERVICE-scan.json 2>/dev/null || echo "0")
            HIGH_COUNT=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "HIGH")] | length' trivy-reports/$SERVICE-scan.json 2>/dev/null || echo "0")
            MEDIUM_COUNT=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "MEDIUM")] | length' trivy-reports/$SERVICE-scan.json 2>/dev/null || echo "0")
            echo "- **$SERVICE:** $CRITICAL_COUNT critical, $HIGH_COUNT high, $MEDIUM_COUNT medium" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **$SERVICE:** Scan results not available" >> $GITHUB_STEP_SUMMARY
          fi
        done
        
        # Add cluster health info
        ACTIVE_INSTANCES=$(aws ecs describe-clusters --clusters $CLUSTER_NAME --query 'clusters[0].registeredContainerInstancesCount' --output text)
        echo "**Active EC2 Instances:** $ACTIVE_INSTANCES" >> $GITHUB_STEP_SUMMARY
        echo "**Admin Service Port:** 8001" >> $GITHUB_STEP_SUMMARY
        
        # Add service status
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Service Status" >> $GITHUB_STEP_SUMMARY
        for SERVICE in $SERVICES; do
          SERVICE_NAME="YANTECH-${SERVICE}-service-$ENVIRONMENT"
          RUNNING_COUNT=$(aws ecs describe-services --cluster $CLUSTER_NAME --services $SERVICE_NAME --query 'services[0].runningCount' --output text 2>/dev/null || echo "0")
          DESIRED_COUNT=$(aws ecs describe-services --cluster $CLUSTER_NAME --services $SERVICE_NAME --query 'services[0].desiredCount' --output text 2>/dev/null || echo "0")
          echo "- **$SERVICE:** $RUNNING_COUNT/$DESIRED_COUNT running" >> $GITHUB_STEP_SUMMARY
        done
        
        if [[ "$IS_RELEASE" == "true" ]]; then
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Release:** $VERSION_TAG" >> $GITHUB_STEP_SUMMARY
          echo "**GitHub Release:** Created automatically" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "âœ… **Status:** Deployment process completed" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "ðŸ“Š **Security:** View detailed vulnerability reports in artifacts" >> $GITHUB_STEP_SUMMARY
        echo "ðŸ’¡ **Troubleshooting:** If services are not healthy, run \`./debug-ecs-deployment.sh $ENVIRONMENT\` for detailed diagnostics" >> $GITHUB_STEP_SUMMARY